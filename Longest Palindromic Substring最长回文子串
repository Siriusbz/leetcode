//Solution1:中心扩散法（快，内存消耗小）
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length()<1){
            return "";  //空串
        }
        int start=0, end=0;  //记录回文子串的起止位置
        for(int i=0;i<s.length();i++){
            //返回当前位置最长回文子串长度,考虑单双中心
            int len1 = centerexpand(s, i, i);  //单中心
            int len2 = centerexpand(s, i, i+1);  //双中心
            int len = max(len1, len2);
            if (len>end-start){
                start = i - (len-1)/2;
                end = i + len/2;
            }
        }
        return s.substr(start, end-start+1);

    }
    int centerexpand(string s, int left, int right){
        int l = left, r = right;
        while(l>=0 && r<s.length() && s[l]==s[r]){
            l--;
            r++;
        }
        return r-l-1;  //从下标0开始，按该式计算结果正确
    }
};

//动态规划法
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length();
        vector<vector<int>> dp(len, vector<int>(len));
        if (len<2){  //如果是单字符的串，则直接返回，必是回文串
            return s;
        }
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        int maxlen = 1;
        int begin = 0;
        for(int l=2;l<=len;l++){
            for(int i=0;i<len;i++){
                //l是子串长，i是串左边界，可知右边界j-i+1=l
                int j=l+i-1;
                if (j >= len) {  //j越界
                    break;
                }
                if(s[i]!=s[j]){
                    dp[i][j]=false;
                }
                else{
                    if(j-i<3){  //s[i]=s[j]且长度为1，2，必是回文串
                        dp[i][j]=true;
                    }
                    else{
                        dp[i][j]=dp[i+1][j-1];  //如果s[i]=s[j]，则s[i,j]串是否回文由其子串决定
                    }
                }
                if(dp[i][j]&&j-i+1>maxlen){
                    maxlen = j-i+1;
                    begin = i;
                }
            }
        }
        return s.substr(begin,maxlen);
    }
};
