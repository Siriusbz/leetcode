//discription:给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
/*输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。*/
//solution1：滑动窗口
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.size();
        unordered_set<char> longeststr;  //创建一个哈希集合
        //采用双指针方法进行滑动
        int r=-1;  //右指针
        int ans = 0;  //记录最长的无重复字符子串
        for(int i=0;i<len;i++){  //i是左指针
            if(i!=0){  //初始不满足，当后续执行到此，说明滑动过程中，串出现了重复字符
                longeststr.erase(s[i]);    //擦除最左（即使不是与最左侧重复，最左字符也要排除）
            }
            while(r+1<len && !longeststr.count(s[r+1])){
                //unordered_set::count()返回0或1，0表示不在，1表示在。
                //该循环在条件为真时向集合内添加新字符，因此当!longeststr.count(s[r+1])为1时，表示新字符不在哈希集合内
                longeststr.insert(s[r+1]);
                ++r;
            }
            ans = max(ans, r-i+1);
        }
        return ans;
    }
}；
//solution2：hash map优化
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int start = 0;  //int start(0);
        int end = 0;
        int length = 0;
        int ans = 0;
        int len = s.size();
        unordered_map<char, int> hash;  //类似于python的字典，由键值对组成
        while(end<len){
            char tmp = s[end];  //记录当前值
            //判断tmp是否在hash表中，如果find找到tmp则会返回当前位置迭代器，否则返回hash.end()
            //因此该条件为true表示tmp出现过
            //hash记录tmp的最后一次出现的位置，tmp如果出现在start之后，表示存在重复。
            //因此该条件为true表示tmp出现过
            //整体条件为true表示tmp出现过，需要修改起始位置
            if(hash.find(tmp)!=hash.end() && hash[tmp]>=start){  
                start = hash[tmp] + 1;  //更新start
                length = end - start;  //更新子串长度
            }
            hash[tmp] = end;  // 存储当前字符和其出现的下标
            end++;  //右移右指针
            length++;  //当前子串的长度加1
            ans = max(ans,length);
        }
        return ans;
    }
};
